package com.moshy

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.nullable
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.encoding.CompositeDecoder
import kotlinx.serialization.serializer
import org.slf4j.LoggerFactory
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import kotlin.reflect.KProperty1
import kotlin.reflect.KType
import kotlin.reflect.full.findAnnotation
import kotlin.reflect.full.memberFunctions
import kotlin.reflect.full.memberProperties
import kotlin.reflect.full.withNullability

@Suppress("UNCHECKED_CAST")
private fun <T> KSerializer<*>.cast() = this as KSerializer<T>

/**
 * Holds mappings and special objects used by the actual serialization functions.
 */
/* If we have an autogenerated data class with >245 parameters, copy() will be non-functional due to JVM method arg
 * limitations. Check during serializer generation that this problem will not occur.
 * NOTE: this is a JVM limitation. Once this code uses KSP and therefore can work with multiplatform, this shouldn't be
 *       an issue.
 */
private const val KT_JVM_ALL_PARAMS_OPTIONAL_ARG_COUNT_LIMIT = 245

internal class PropsPack private constructor(
    val descriptor: SerialDescriptor,
    val propsByIndex: List<KProperty1<*, *>>,
    val propIndicesByName: Map<String, Int>,
    val propNamesLowercase: Map<String, String>,
    val propsSerializers: List<KSerializer<Any?>>,
    val recurseAtIndex: List<Boolean>,
) {
    companion object {
        fun fromSerialType(sType: SerialType): PropsPack {
            val kClass = sType.type.kClass
            val isGeneric = sType.type.arguments.isNotEmpty()
            if (isGeneric)
                throw IllegalArgumentException("class ${sType.type.kClass.className} is generic; support is missing")
            require(kClass.isData) {
                "class ${kClass.className} is not a data class"
            }
            /* Non-private var properties declared in the data class body are serializable but are not available as
             * parameters to copy. This is a problem because our goal is to use copy() for lensed updates instead of
             * invoking the constructor to set the body-declared var's (which is what the underlying deserializer does).
             * To emit a warning that a serializable property is not copy method accessible as necessary, get a list of
             * parameter names.
             */
            val copyAccessiblePropertyNames =
                kClass.memberFunctions.single { it.name == "copy" }.parameters.mapNotNull { it.name }.toSet()

            val indexToProperty = mutableListOf<KProperty1<*, *>>()
            val nameToIndex = mutableMapOf<String, Int>()
            val namesCasemap = mutableMapOf<String, String>()
            val indexToSerializer = mutableListOf<KSerializer<Any?>>()
            val recursionNeeded = mutableListOf<Boolean>()
            // make a mutable list of descriptors since we can't create our own ClassSerialDescriptorBuilder instance
            val descriptors = mutableListOf<Triple<String, SerialDescriptor, List<Annotation>>>()
            var serialIndex = 0
            for (prop in kClass.memberProperties) {
                val propName = prop.name
                // the kx-serialization compiler plugin makes sure that all prop serial names per kClass are unique
                val propSerialName = prop.findAnnotation<SerialName>()?.value ?: propName
                // use class serial descriptor to query serializability
                @OptIn(ExperimentalSerializationApi::class)
                val sTypeSerialIndex = sType.descriptor.getElementIndex(propSerialName)
                if (sTypeSerialIndex == CompositeDecoder.Companion.UNKNOWN_NAME) {
                    if (propName in copyAccessiblePropertyNames) {
                        warnNonSerializableParameterInCopyMethod(logger, kClass, propName)
                    }
                    continue
                }
                if (propName !in copyAccessiblePropertyNames) {
                    warnParameterInaccessibleInCopyMethod(logger, kClass, propName)
                    continue
                }
                val propType = prop.returnType
                /* Strip the nullability off the property's type so we can get the serializer for its underlying
                 * type; this will allow us to attach our proxy serializer to the type then add the nullability
                 * handler over it.
                 */
                val propTypeDenullabled = propType.withNullability(false)
                val isDataclass = propTypeDenullabled.kClass.isData
                val isNullable = propType.isMarkedNullable
                val isNullableDataclass = isNullable && isDataclass
                // we only care about re-wrapping nullability for data classes
                val underlyingType =
                    if (isNullableDataclass)
                        propTypeDenullabled
                    else
                        propType
                indexToProperty += prop
                if (sType.caseFold) {
                    val nameLower = prop.name.lowercase()
                    val oldNameMatch = namesCasemap.put(nameLower, prop.name)
                    require(oldNameMatch == null) {
                        casefoldNameCollision(kClass, prop.name, nameLower)
                    }
                }
                nameToIndex[prop.name] = serialIndex
                recursionNeeded += isDataclass
                indexToSerializer += elementSerializer(prop, underlyingType, isDataclass, isNullableDataclass).cast()
                @OptIn(ExperimentalSerializationApi::class)
                descriptors += Triple(
                    propSerialName,
                    sType.descriptor.getElementDescriptor(sTypeSerialIndex),
                    prop.annotations
                )
                ++serialIndex
                check (serialIndex <= KT_JVM_ALL_PARAMS_OPTIONAL_ARG_COUNT_LIMIT) {
                    val limit = KT_JVM_ALL_PARAMS_OPTIONAL_ARG_COUNT_LIMIT
                    "Encountered data class with >$limit eligible properties; this should be impossible on JVM"
                }
            }

            val proxyDescriptor = buildClassSerialDescriptor("ProxyMap<${kClass.className}>") {
                for ((name, descriptor, annotations) in descriptors)
                    element(name, descriptor, annotations, isOptional = true)
            }

            return PropsPack(
                proxyDescriptor,
                indexToProperty,
                nameToIndex,
                namesCasemap,
                indexToSerializer,
                recursionNeeded
            )
        }

        private val logger by lazy { LoggerFactory.getLogger("ProxyMap.PropsPack") }
    }
}

private fun elementSerializer(
    prop: KProperty1<*, *>,
    underlyingType: KType,
    isDataclass: Boolean,
    isNullableDataclass: Boolean
): KSerializer<out Any?> {
    /* @Serializable(with=X) requires X to be a compile-time KClass so use
     *      ?.objectInstance to unpack a runtime-usable object
     */
    val propActualSerializer =
        prop.findAnnotation<Serializable>()?.with?.objectInstance
            ?: serializer(underlyingType)

    if (isDataclass) {
        // unwrap the nullability then rewrap it if necessary
        val dataclassDeserializer = ProxyMapSerializer(propActualSerializer.cast())
        if (isNullableDataclass)
            return dataclassDeserializer.nullable
        return dataclassDeserializer
    }
    return propActualSerializer
}

internal val PROPS_PACK_CACHE = ConcurrentHashMap<SerialType, PropsPack>()
internal fun ConcurrentMap<SerialType, PropsPack>.getOrPutEntry(sType: SerialType) =
    getOrPut(sType) { PropsPack.fromSerialType(sType) }
