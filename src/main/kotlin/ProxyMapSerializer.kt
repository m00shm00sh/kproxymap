package com.moshy

import java.util.concurrent.ConcurrentHashMap
import kotlinx.serialization.*
import kotlinx.serialization.builtins.nullable
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.*
import java.util.TreeMap
import kotlin.reflect.*
import kotlin.reflect.full.*
import kotlin.reflect.jvm.jvmName

private val KType.kClass: KClass<*>
    get() = when (val t = classifier) {
        is KClass<*> -> t
        /* This line will only get triggered if we made an internal mistake unpacking types;
         * thus it should be excluded from coverage analysis.
         * File a bug report if this gets triggered in normal use!
         */
        else -> throw IllegalStateException("Type $t is not a class")
    }

@Suppress("UNCHECKED_CAST")
private inline fun <reified T> KSerializer<*>.cast() = this as KSerializer<T>

/**
 * Serializing type consisting of a type and its associated serializer.
 * This is a distinct object so it can be used as a cache key, given the cost of reflection.
 */
private data class SerialType(
    val type: KType,
    val descriptor: SerialDescriptor
)

// internal for testing, to trap System.err.println calls
internal var errorStream = System.err

private val KClass<*>.className
    get() = qualifiedName ?: simpleName ?: jvmName

// FIXME: this should be refactored to slf4j calls and use of an internal errorCallbackTriggered
private fun warnParameterInaccessibleInCopyMethod(kClass: KClass<*>, propName: String) {
    val className = kClass.className
    errorStream.println(
        "Serializable property $propName of class $className is not accessible from copy method"
    )
}
private fun warnNonSerializableParameterInCopyMethod(kClass: KClass<*>, propName: String) {
    val className = kClass.className
    errorStream.println(
        "Property $propName of class $className is a param of copy method but not serializable"
    )
}
private fun warnIgnoredMapKeyDuringSerialization(keyName: String) {
    errorStream.println(
        "Ignored key \"$keyName\" because it is not a viable serialization candidate"
    )
}

/**
 * Holds mappings and special objects used by the actual serialization functions.
 */
/* Optimization opportunity: kx serialization uses ArrayList's internally to hold the index to name mappings and
 * in the public API, indices are guaranteed to be non-negative. However, contiguity is unspecified.
 * We could replace Map<Int, T> with ArrayList<T?> by capturing the highest index and creating an ArrayList of nulls
 * then filling in the applicable values. The expected size of this ArrayList will be <= 245 elements, as calculated by
 * the following constraints:
 * (1) JVM has a run-time limit of 255 parameters. Two of these slots are taken up by the instance and a tag object that
 *     disambiguates the overload taking optional arguments. For a suspend function, a third slot is taken up by the
 *     continuation.
 * (2) All arguments are optional in `copy()`, therefore ceil(nProperties/32) slots are taken up by a bit-map that
 *     specifies these optional fields (see how callBy shapes the arg map into an arg list[1]).
 * This gives us a formula of `2 + x + ceil(x/32) <= 255`, which gives us a maximum `x` of 245.
 * We can observe that the serializer plugin serializes properties declared in the primary constructor first then
 * continues with accessible body-declared properties. What this means is the first 245 properties by serialization
 * index can be considered. Note that serialization index and `KClass<*>.memberProperties` indices have no guarantees
 * of matching: java/lang/Class.getDeclaredMethods() produces a Collection dressed up as an Array and memberProperties
 * behaves likewise. We must inspect parameters of copy() to figure out if we get something usable.
 * In all practicality, a data class with 245 properties declared in the primary constructor is autogenerated insanity,
 * but we *do* have an upper limit.
 * Query and insert semantics will remain unchanged.
 * [1] https://github.com/JetBrains/kotlin/blob/HEAD/core/reflection.jvm/src/kotlin/reflect/jvm/internal/KCallableImpl.kt#L152
 *     is the method that KCallable<*>.callBy ultimately calls under the hood
 */
private data class PropsPack(
    val descriptor: SerialDescriptor,
    val kClass: KClass<*>,
    val propsByIndex: Map<Int, KProperty1<*, *>>,
    val propIndicesByName: Map<String, Int>,
    val propsSerializers: Map<Int, KSerializer<Any?>>,
    val recurseAtIndex: Set<Int>,
) {
    companion object {
        fun fromSerialType(sType: SerialType): PropsPack {
            val kClass = sType.type.kClass
            /* Non-private var properties declared in the data class body are serializable but are not available as
             * parameters to copy. This is a problem because our goal is to use copy() for lensed updates instead of
             * invoking the constructor to set the body-declared var's (which is what the underlying deserializer does).
             * To emit a warning that a serializable property is not copy method accessible as necessary, get a list of
             * parameter names.
             */
            val copyAccessiblePropertyNames =
                kClass.memberFunctions.single { it.name == "copy" }.parameters.map { it.name }.toSet()

            val indexToProperty = mutableMapOf<Int, KProperty1<*, *>>()
            val nameToIndex = mutableMapOf<String, Int>()
            val indexToSerializer = mutableMapOf<Int, KSerializer<Any?>>()
            val recursionNeeded = mutableSetOf<Int>()

            for (prop in kClass.memberProperties) {
                val propName = prop.name
                // the kx-serialization compiler plugin makes sure that all prop serial names per kClass are unique
                val propSerialName = prop.findAnnotation<SerialName>()?.value ?: propName
                @OptIn(ExperimentalSerializationApi::class)
                val serialIndex = sType.descriptor.getElementIndex(propSerialName)
                if (serialIndex == CompositeDecoder.UNKNOWN_NAME) {
                    if (propName in copyAccessiblePropertyNames) {
                        warnNonSerializableParameterInCopyMethod(kClass, propName)
                    }
                    continue
                }
                if (propName !in copyAccessiblePropertyNames) {
                    warnParameterInaccessibleInCopyMethod(kClass, propName)
                    continue
                }
                val propType = prop.returnType
                /* Strip the nullability off the property's type so we can get the serializer for its underlying
                 * type; this will allow us to attach our proxy serializer to the type then add the nullability
                 * handler over it.
                 */
                val propTypeDenullabled = propType.withNullability(false)
                val propClass: KClass<*> = propTypeDenullabled.kClass
                val isDataclass = propClass.isData
                val isNullable = propType.isMarkedNullable
                val isNullableDataclass = isNullable && isDataclass
                // we only care about re-wrapping nullability for data classes
                val underlyingType =
                    if (isNullableDataclass)
                        propTypeDenullabled
                    else
                        propType

                indexToProperty[serialIndex] = prop
                nameToIndex[prop.name] = serialIndex
                if (isDataclass)
                    recursionNeeded.add(serialIndex)
                indexToSerializer[serialIndex] =
                    elementSerializer(
                        prop, underlyingType, isDataclass, isNullableDataclass
                    ).cast<Any?>()
            }

            return PropsPack(sType.descriptor, indexToProperty, nameToIndex, indexToSerializer, recursionNeeded)
        }
    }
}

private fun elementSerializer(
    prop: KProperty1<*, *>,
    underlyingType: KType,
    isDataclass: Boolean,
    isNullableDataclass: Boolean
): KSerializer<out Any?> {
    /* @Serializable(with=X) requires X to be a compile-time KClass so use
     *      ?.objectInstance to unpack a runtime-usable object
     */
    val propActualSerializer =
        prop.findAnnotation<Serializable>()?.with?.objectInstance
            ?: serializer(underlyingType)

    if (isDataclass) {
        // unwrap the nullability then rewrap it if necessary
        val dataclassDeserializer = ProxyMapSerializer(propActualSerializer.cast<Any>())
        if (isNullableDataclass)
            return dataclassDeserializer.nullable
        return dataclassDeserializer
    }
    return propActualSerializer
}

/**
 * Actual serializer for [propsP].
 */
private fun serializeProxyMap(propsP: PropsPack, encoder: Encoder, value: Map<String, Any?>) {
    val descriptor = propsP.descriptor
    val propsIndices = propsP.propIndicesByName
    val propsSerializers = propsP.propsSerializers

    /* Extract the keys to serialize from [value] and produce a map in serialization index order so that
     * we encode the elements in the same order the proxied class does.
     * Use TreeMap().apply because buildMap produces a hash map instead of a sorted map and we need ordering
     * by key value.
     */
    val toSerialize = TreeMap<Int, Any?>().apply {
        for ((propName, propValue) in value) {
            propsIndices[propName]?.let {
                this[it] = propValue
            } ?: warnIgnoredMapKeyDuringSerialization(propName)
        }
    }

    encoder.encodeStructure(descriptor) {
        for ((serialIndex, value) in toSerialize) {
            val elem = when {
                value == null -> null
                @Suppress("UNCHECKED_CAST")
                serialIndex in propsP.recurseAtIndex -> ProxyMap<Any>(value as Map<String, Any?>)
                else -> value
            }
            encodeSerializableElement(descriptor, serialIndex, propsSerializers[serialIndex]!!, elem)
        }
    }
}

/**
 * Actual deserializer for [propsP].
 */
private fun deserializeProxyMap(propsP: PropsPack, decoder: Decoder): Map<String, Any?> {
    val descriptor = propsP.descriptor
    val propsByIndex = propsP.propsByIndex
    val propsSerializers = propsP.propsSerializers

    return buildMap {
        decoder.decodeStructure(descriptor) {
            /* We do not support decodeSequentially because it only makes sense for ordered full objects, not
             * named lens partial objects.
             */
            while (true) {
                when (val index = decodeElementIndex(descriptor)) {
                    CompositeDecoder.DECODE_DONE -> break
                    /* If CompositeDecoder.decodeElementIndex() never returns UNKNOWN_NAME, this case can be removed
                     * entirely instead of just being commented out.
                     */
                    // CompositeDecoder.UNKNOWN_NAME -> continue
                    else -> {
                        val deserialized = decoder.decodeSerializableValue(propsSerializers[index]!!)
                        put(propsByIndex[index]!!.name, deserialized)
                    }
                }
            }
        }
    }
}

private val PROPS_PACK_CACHE = ConcurrentHashMap<SerialType, PropsPack>()

/**
 * Provides a serializer to encode/decode a Map<String, Any?> as if it were a @Serializable (data) class C.
 */
class ProxyMapSerializer<T: Any>(classSerializer: KSerializer<T>): KSerializer<ProxyMap<T>> {
    override val descriptor = classSerializer.descriptor
    // use reflection to find the run-time type of T
    // TODO: is this cacheable? Is the KSerializer a usable caching key or do we need something else?
    private val type = (classSerializer::class.memberFunctions.find { it.name == "deserialize" }?.returnType!!
        ).also {
            require(it.kClass.isData) {
                "(de)serializer synthesis only supported for data classes"
            }
        }
    private val sType = SerialType(type, classSerializer.descriptor)
    private val propsP = PROPS_PACK_CACHE.getOrPut(sType) { PropsPack.fromSerialType(sType) }

    val serializableMemberPropertyCount = propsP.propsByIndex.size
    override fun deserialize(decoder: Decoder): ProxyMap<T> =
        ProxyMap(deserializeProxyMap(propsP, decoder))
    override fun serialize(encoder: Encoder, value: ProxyMap<T>) =
        serializeProxyMap(propsP, encoder, value)
}

/** Tag type for (de)serialization as update map for data class [T]. */
@Serializable(with = ProxyMapSerializer::class)
class ProxyMap<T: Any>(): HashMap<String, Any?>() {
    internal constructor(m: Map<String, Any?>): this() {
        putAll(m)
    }
}
